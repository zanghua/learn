### 0、软件设计（同步）


#### 六、面向对象设计

1、基本概念
|- 对象：属性、方法、对象ID
|- 类：（实体类、控制类、边界类）

2、面向对象七大设计原则
（1）单一职责
（2）开关原则
（3）里氏替换
（4）接口隔离
（5）迪米特法则
（6）多用组合
（7）依赖倒置

3、UML 2.0
|- 结构图（类图、对象图、包图、构件图、组合结构图、部署图、制品图）
|- 行为图（用例、顺序图、通信、定时、状态、活动、交互概览图）

4、类图
|- 依赖：虚线 三角实心
|- 泛化继承：实线 （箭头）三角空心
|- 关联：实线 没有箭头
|- 组合：实线 实心菱形
|- 聚合：实线 空心菱形
|- 实现（接口）：虚线 空三角

5、设计模式分类
|- 创建型：抽象工厂、工厂方法、单例、原型、构建（创建）--》
|- 结构型：组合、装饰、适配器、代理、桥接、享元、外观 --》组装适配器，代理乔元外
|- 行为型：







七、数据结构与算法

1、数组
|- 一维  a[i] = a + i * len
|- 二维  按行存储 a[i][j] = a + (i*n+j)*len
|- 二维  按列存储 a[i][j] = a + (j*m+i)*len

2、稀疏矩阵
|- 下三角 (i+1)* i / 2 + j
|- 上三角 (2n - i + 1) * i / 2 + j

3、循环队列
|- 空队列 ：相等是空
|- 满队列 : + 1 等 front 为满

4、广义表
|- 只有取头、取尾操作，取尾是取除头外的全问。
|- 深度：括号个数，长度：第一层元素数。

5、树与二叉树
|- 二叉树：最大度为2
|- 满二叉树：2K - 1的结点
|- 完全二叉树：按层级编号，与满二叉树编号相同。
|- 查询二叉树：左分支 都小于根，右分支都大于根
|- 最优二叉树（哈夫曼树）：最小两节点相加，生成父节点，再找最小两节点相加生成父节点。最后所有原来的全变成叶子节点。
|- 平衡二叉树：左右高度差不超过1，且左右子树也是平衡树。红黑树、AVL

|- 树与二叉树遍历：前序、中序、后序、层级。根左右、左根右、左右根、
|- 树转二叉树：
  |- 加线：在所有兄弟节点加线
  |- 去线：只保留与第一个孩子的连线
  |- 调整：第一个孩子是左孩子，兄弟为自己的右孩子。

6、图
|- 有向图（有箭头）、无向图
|- 邻表矩阵：1 有邻接琏 0 无
|- 邻接表（考点）：所有点组成数组（列），（行）单个点所有连接其他点（边）组成链表。
|- 图的遍历：
  |- 从任意点出发对所有点访问一次，只访问一次。
  |- 深度遍历：从一边到底，类似根左右
  |- 广度遍历：按层遍历
|- 拓扑排序：在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面。
|- 最小生成树：带权相加取最小的。关键路径：取所有为0的

7、算法
|- 特性：有穷性、确定性、输入、输出、可行性
|- 查询算法
  |- 顺序查找：O（n）
  |- 二分查找(必须有序)：O(log2 N)
  |- 散列查找;
|- 排序算法（内部排序、外部排序），内存中完成为内部排序
  |- 稳定排序：相同元素位置不变为稳定排序。插入、冒泡、归并、基数。
  |- 就地排序：空间复杂度，O（1），不随输入规模的影响就是就地排序。

  |- 插入排序：将一个记录插入到已经排好的有序表中，从而得到一个新的。
  |- 希尔排序：是插入排序改进，增量分组，再使用插入排序，当到1时结束

  |- 选择排序：第一趟选择出最大（小）放到数列最前，直到全部排序完成。
  |- 堆排序：完全二叉树。最大堆要求所有孩子都小于根节点。最小堆相反。每次取堆顶放到数列，重新调整。
  交换排序：
  |- 冒泡排序：重复走访要排序的元素，两两相比，进行交换。
  |- 快速排序：冒泡改进，二分思想，取一基准数，一趟分为两部分，再进行快速排序。

  |- 归并排序：分治法，紧次于快排。每将每个子序有序。再合并。
  |- 基准排序：分配式排序，统一数位长度，按位排序。






