# 大话数据结构
## 1.    数据结构
### 1.1.    基础
#### 基础概念与术语

1、数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。

2、数据元素：是组成数据的、有一定意义 的基本单位，在计算机中通常作为一个整体处理。也可以称为记录。

3、数据项：一个数据元素有有多个数据项组成，数据项是数据不可分割的最小单位。

4、数据对象：是性质相同的数据元素的集合，是数据的子集。

从大到小：数据 -》 数据对象 -》 数据元素 -》数据项

#### 数据结构

1、数据结构：结构就是关系，数据结构就是指相互之间存在一种或多种特定关系的数据元素的集合。

2、按照视点不同，数据结构又分为逻辑结构和物理结构

3、逻辑结构：是指数据对象中数据元素之间的关系。这是今后主要要关注的问题。

    |- 集合结构：集合结构中数据元素除了同属于一个集合外，它们之间没有任何关系。

    |- 线性结构：一对一，线性结构中的数据元素之间是一对一的关系 。

    |- 树形结构：一对多，树形结构中的数据元素之间存在一种一对多的层次关系。

    |- 图形结构：多对多，图形结构中数据元素是多对多关系 。

4、物理结构：是指数据在逻辑结构在计算机中的存储形式。

    |- 顺序存储结构：是把数据元素存入在地址连续的存储单元 里，其数据间的逻辑关系 和物理关系是一致的。

    |- 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续。数据元素的存储关系 并不能反映其逻辑关系，因此需要一个指针存放有关系 的数据元素的地址，这样映射它们之间的关系 。



抽象数据类型：理解一下。

抽象就是把共性的抽取出来，定义一个更高层的类别。

### 1.2.    算法

1、算法：描述解决特定问题求解的步骤，在计算机中体现为指令的有限序列，且每个指令表示一个或多个操作。

2、数据结构与算法的关系：事实上，数据结构和算法是紧密相关的解决一些特这问题。只谈数据结构，在很短的时间就把几种重要的数据结构介绍完了。了解完了，很可能没什么感觉，不知道数据结构有何用，但如果我们把相应的算法也学一下，就会发现甚至感慨：计算机界的前辈们，的确是一些很牛的人，他们把看似很难解决或没法解决的问题，解决的如此美妙和神奇。也许以后大家不在崇拜帅哥美女了，而是崇拜大胡子和秃顶。

3、两种算法的比较：累加的实现，循环和高斯求和。

4、高斯求和：sum = (n + 1) * n / 2

5、算法的特性

    |- 输入输出：算法具有零个或多个输入，至少有一个或多个输出。hello 没有输入。

    |- 有穷性：指的算法执行有限的步骤后，自动结束，而不会出现无限循环，并且每一个步骤都是在可接受的时间内完成的。

    |- 确定性：算法的每一个步骤都具有确定的含义，不会出现二义性，歧义。

    |- 可行性：算法的每一步必须是可行的，也就是说，每一个步骤都能够通过执行有限的次数完成。

6、算法的设计要求：（1）正确性、（2）可读性、（3）健壮性、（4）时间效率高和存储量低

7、算法的度量方法：（1）事后统计方法 （不靠谱） （2）事前分析估算方法

8、事前分析估算方法：在计算机程序编制前，依据统计 方法对算法进行估算。

    |- 经过分析发现，一个程序在计算机上运行的时间（消耗的时间）取决于下列因素：

    （1）算法采用的策略、方法

    （2）编译产生的代码质量（软件环境）

    （3）问题的输入规模

    （4）机器执行指令的速度（硬件环境）

    |- 也就是说，抛开这些软硬件环境，一个程序的运行时间，取决于算法 的好坏 和 问题的输入规模。输入规模就是输入量的多少。

    |- 从累加例子上，来看，一个算法的好坏 取决它运行的次数（运行时间），当然存储量低也是一方面。

9、函数的渐近增长：两个函数，随着输入规模的增大，一个函数越来好于别一个函数，或越来越差于另一函数。这种现象就是渐近增长。

10、算法的时间复杂度：在进行算法分析时，主要分语句总的执行次数随输入规模n的变化并确定 执行次数的数量级。大O 记法（时间复杂度的记法）。

11、推导大O的方法

    |- 用常数1取代表达式中所有加法的常数。

    |- 在修改后的运行次数表达式中，只保留最高阶项。

    |- 如果高阶项存在且不是1，则去除与这个项相乘的常数。最后得到的就是大O阶。

12、常见的时间复杂度

    |- 常数阶 -》对数阶 -》线性阶 -》nlogn阶 -》平方阶 -》立方阶 -》指数阶

    |- O(1)   -》O(logn)-》O(n)-》 O(nlogn)-》 O(n二次方)-》  O(n三次方)-》 O(n的n次方)

13、算法的空间复杂度：空间换时间。

## 1.3.线性表
### 1.3.1.线性表
1、线性表

    |- 定义：零个或多个数据元素的有限序列。
    |- 解释：
    （1）首先是个序列，也就是数据元素是有顺序的，
    （2）若元素存在多个，第一个无前驱，最后一个无后继。
    （3）其他每个元素有前驱和后继。
2、线性表顺序存储结构

    |- 指的是用一段地址连续的存储单元依次存储线性表中的数据元素。
    |- C语言（其他语言也是）用一维数据来实现顺序存储结构。占位的形式把内存占了。
    |- 优点：
    （1）无须为元素之间的逻辑关系增加额外的存储空间。
    （2）可以通过索引快速存取任意位置的元素。
    |- 缺点：
    （1）插入和删除操作需要移动大量元素
    （2）当线性表长度变化较大时，难以确定存储空间的大小。

3、线性表的链式存储结构

    |- 结点：由数据域和指针域组成。数据域存储数据元素的数据，指针域存了前驱和后续的结点地址。
    |- 头指针：
    （1）是指链表指向第一个结点的指针
    （2）头指针具有标识作用，所以常用头指针冠以链表的名字。
    |- 单链表: 只有一个指针，对向下一个元素，称为单链表。
    |- 单链表的读取时间很杂度，O(n)

4、单链表结构与顺序存储结构

存储方式

    |- 顺序存储一段连续的存储单元依次存储线性表的数据元素
    |- 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。
时间性能

    |- 查询：顺序O（1），单链表 O（n）
    |- 插入和删除
        |- 顺序存储结构需要平均移动表长的一半的元素，时间为O（n）
        |- 单链表在查出某位置的指针后，插入和删除时间仅为O（1）

空间性能

    |- 顺序存储结构需预分配存储空间，分大了，浪费，分小了易发生溢出
    |- 单需要分析存储间，只要有就可以分配，元素个数也不限制。

总结：

    |- 查找多时，宜采用顺序存储结构。插入或删除多时宜采用单链表结构。
    |- 元素个数变化较大时最好使用单链表存储。如果事先知道大致长度适合顺序存储。

5、静态链表

    |- 让数组的元素有两个域组成，data和cur。也就是数组的每一个下标都对应一个data和cur。数据域data存放数据。游标cur相当于单链表中的next指针。我们把这种用数组描述的链表叫做 静态链表。
    |- 优点：在插入和删除时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中的移动大量元素的缺点。
    |- 缺点1：没有解决连续存储分配带来的表长难以确定的问题。
    |- 缺点2：失去了顺序存储的随机读取的特性。

6、循环链表

    |- 最后一个节点的指针 指向了 第一个节点。
    |- 解决了一个问题，从当中任何一个节点出发都可访问全部节点。

7、双向链表

    |- 每个节点都有一个两个指针，指向前一个节点和后一个节点。

8、总结：

    （1）线性表是零个或多个具有相同类型的数据元素的有限序列。
    （2）线性表两大存储结构，顺序存储结构以通用都用数组。
    （3）后来是重点，由于顺序存储的插入和删除操作不方便，引出了链式存储结构。它具有不用存储空间限制，可以比较快捷的插入和删除的优点。然后我们就链式存储不同形式，如单链表、循环链表、双向链表做了讲解。同时还引出若不用指针如何处理链表结构的静态链表方法。
    （4）总的来说，线性表的这两种存储结构是后面其他数据结构的基础，把它学明白了，对后面的学习有着至关重要的作用。

### 1.4.    栈与队列

1、栈（stack）是限定仅在表尾进行插入和删除操作的线性表。例：弹夹 手枪
2、队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表
#### 1.4.1.    栈
1、栈（stack）是限定仅在表尾进行插入和删除操作的线性表。例：弹夹 手枪

    |- 允许插入和删除的一端称为栈顶top，另一端称为栈底bottom。
    |- 不含任何数据元素的栈称为空栈。
    |- 栈又称为后进先出（先进后出 last in first out）的线性表，简称LIFO
    |- 取出 pop ,push
2、栈的顺序存储结构

3、栈的链式存储结构，简称链栈

4、小结：如果栈的使用过程中元素变化不可预料，最好用链式存储，反之建议使用顺序存储。

5、栈的应用：递归

    |- 斐波那契数列：如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生一对。假设所有兔子都不死，那么一年后一共有多少兔子呢。
    |- 分析：

1    2    3    4    5    6    7    8    9    10    11    12

1    1    2    3    5    8    13    21    34    55    89    144

这个数列有个特点：后一项 = 前面相邻两项之和。

定义一下函数：F(n) =

    |- 当n=0, F（n）=0
    |- 当n=1,F（n）=1
    |- 当n>1,F（n）=F(n-1) + F(F-2)

递归：一个直接调用自己或间接调用息的函数，称为递归函数。递归应该必须至少有一个条件，满足时递归不再进行。

6、栈的应用：四则运算

    |- 后缀表示法 逆波兰表示
    |- 将中缀转换为后缀表示。规则：从左到右遍历中比对表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到输出后缀表达式为止。
    |- 再进行计算，计算规则：从左到右遍历每个数字和符号，遇到数字就进栈，遇到符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

### 1.4.2.    队列

1、队列是只允许在一端进行插入操作，另一端 进行删除操作的线性表。

    |- 队列是一种先进先出FIFO。
    |- 队列 更适合使用 链式存储结构。在删除后，所有的都要移动，不适合顺序存储。

2、循环队列：把队列的这种头尾相接的顺序存储 结构称为循环队列。

### 1.5.    串

1、串：是由零个或多个字符组成的有限序列，也称为字符串。
2、子串的定位操作通常称为串的模式匹配。应该是串的最重要的操作之一。
3、朴素模式匹配算法低效。
4、KMP模式匹配算法：

    a)原理：如果主串S = “abcdefgab”，我们要匹配的 T = “abcdex”，那么如果有前面的朴素算法，前5个字母两个串完全相等，直到第6个字母，f与x不等。如下图

    对于朴素算法这样比较是理所当然的，可仔细观察发现。2、3、4、5判断是多余的。
朴素算法代码：

    public static int kmp(char[] source, char[] target) {
        int sLen = source.length;
        int tLen = target.length;
        int i = 0;
        int j = 0;
        while (i < sLen & j < tLen) {
            if (source[i] == target[j]) {
                i++;
                j++;
            } else {
                i = i - j  + 1;
                j = 0;
            }
        }
        if (j == tLen) {
            return  i - j;
        }
        return -1;
    }

    public static void main(String[] args) {
         String source = "abababef";
         String target = "ababe";
        System.out.println(kmp(source.toCharArray(),target.toCharArray()));
    }


5、KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。

    a) KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。
    b) 具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。

6、next()函数获取next数组，通过前缀与后缀的相同数求出，next数字。

    子串（ababe）    前缀    后缀    最大相同字符长度
    a    无    无    0
    ab    a    b    0
    aba    ab,a    ba,a    1
    abab    aba,ab,a    bab,ab,b    2
    ababe    abab,aba,ab,a    babe,abe,be,e    0

获取的next[]  next=[0,0,1,2,0]

代码实现：

    public static int[] getNext(String subStr) {
        int[] next = new int[subStr.length()];
        next[0] = 0;
        for (int i = 2; i < subStr.length(); i++) {
            int j = i-1;
            while (j > 0) {
                String p = subStr.substring(0, j);
                String a = subStr.substring(i - (j), i);
                if (p.equals(a)) {
                    next[i-1] = j;
                    break;
                }
                j--;
            }
        }
        return next;
    }

7、 参考资料:https://blog.csdn.net/v_july_v/article/details/7041827

### 1.6.    树

1、树：是n(n>=0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：

    a)    有且仅有一个特定的根节点。
    b)    当n>1时，其

