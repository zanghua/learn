# 未分类


## 限流算法

1. 计数器算法
* 实现思路：限制一秒钟请求数，比如限流qps为100，第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。
* 具体实现：对于每次服务调用，可以通过 AtomicLong#incrementAndGet()方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。
* 弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能全部把请求拒绝，我们把这种现象称为“突刺现象”

2. 漏桶算法
* 实现思路：消除"突刺现象"，可以采用漏桶算法实现限流。类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。
* 具体实现：准备一个队列，用来保存请求，另外通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行。
* 弊端：无法应对短时间的突发流量

3. 令牌桶算法
* 实现思路：从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率
* 具体实现：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。

4. 滑动窗口

## 熔断

1. 失败次数、失败比率
