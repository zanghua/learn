## 基础知识

### Java是怎么运行的

* 编译：Java 代码 -> 编译成字节码，大致执行流程：Java 源代码 -> 词法分析器 -> 语法分析器 -> 语义分析器 -> 字节码生成器 -> 最终生成字节码。
* 运行：Hotspot[hatspat] JVM使用类加载器（Class Loader）加载 -> 字节码校验 -> 翻译成机器码 -> 交由操作系统执行。

### JIT

* 不是所有代码都是解释执行的，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）动态编译器,它能够在运行时将热点代码编译为机器码，这时字节码就变成了【编译执行】。

* Java 虚拟机判定热点代码的方式

- 基于采样的热点判定:周期性的检查各个线程的栈顶,若某个方法经常出现在栈顶。缺点是很难精确一个方法的热度，容易受到线程阻塞或外界因素的影响。
- 基于计数器的热点判定：虚拟机给每一个方法甚至代码块建立了一个计数器，统计方法的执行次数，超过一定的阀值则标记为此方法为热点方法。
  - 方法调用计数器：主要就是虚拟机给每一个方法甚至代码块建立了一个计数器，统计方法的执行次数，超过一定的阀值则标记为此方法为热点方法。
  - 回边计数器：主要统计的是方法中循环体代码执行的次数。

### 类加载机制

![img](.\img\01.jpeg)

- 参考：[Java类加载机制，你理解了吗？](https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc)

* 在什么时候才会启动类加载器？

    类加载器并不需要等到某个类被“首次主动使用”时再加载它。

* 类的加载过程

    类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个**生命周期包括：加载、验证、准备、解析、初始化、使用和卸载**七个阶段。加盐被细化十栽。

    ![img](.\img\02.jpeg)

* 加载：通过类名读入二进制字节流，静态 转化为方法区运行时数据结构，在堆中生成代表类的class,作为方法区这个类的访问入口。

* 验证：安全校验

* 准备：**主要为类变量分配内存并设置初始值**。这些内存都在方法区分配

* 解析：是虚拟机将常量池中的符号引用转化为直接引用的过程。

* 初始化：这是**类加载机制**的最后一步，在这个阶段，java程序代码才开始真正执行。类初始化时机：只有当对类的主动使用的时候才会导致类的初始化。

* 使用

* 卸载

### 类加载器

* Bootstrap[ˈbutˌstræps]  ClassLoader ：最顶层的加载类，主要加载核心类库。

  * 环境变量下面%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等
  * 可以通过启动jvm指定-Xbootclasspath和路径来改变加载目录。

* Extention [ɪks'tenʃ(ə)n] ClassLoader:扩展的类加载器.

  * %JRE_HOME%\lib\ext目录下的jar
  * 指定目录：-Djava.ext.dirs=

* Appclass Loader：也称为SystemAppClass。 加载当前应用的classpath的所有类。

* 测试：Thread.cureentThread().getContextClassLoader();

* **双亲委派原则**

* **自定义类加载器**

  * 遵守双亲委派模型：继承ClassLoader，重写findClass()方法。
  * 破坏双亲委派模型：继承ClassLoader，重写loadClass()方法。

  