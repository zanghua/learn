# 数据结构-二叉树
## 1.树

树是由根结点和若干颗子树构成的。兄弟节点互不相交。

## 2.二叉树

最大结点的度为2，也就是最多有两个子节点。

## 3.满二叉树

满二叉树是一种特殊的二叉树，一个k层的二叉树，所有叶子节点都在k层。

## 4.完全二叉树

完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

完全二叉树是一种特殊的二叉树，满足以下要求：
|- 所有叶子节点都出现在 k 或者 k-1 层（叶子节点出现在最后一层或者倒数第二层）
|- 任何一个节点不能只有左子树没有右子树（第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边）

对所有节点进行添加序号，与相同高度满二叉树序号相同。

## 5、二叉排查树（BTS Binary sort tree），又称二叉有序树
二叉查找树（又叫二叉排序树），它是具有下列性质的二叉树：
|- 若左子树不空，则左子树上所有结点的值均小于它的根结点的值
|- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
|- 左、右子树也分别为二叉排序树。

小结：
|- 也就是说，二叉查找树中，左子树都比节点小，右子树都比节点大，递归定义。
|- 根据二叉排序树这个特点我们可以知道：二叉排序树的中序遍历一定是从小到大的。

最优：log(n) 最差：n 链表

小结：遍历，根的位置，在前就前序，在中就叫中序遍历。
前序遍历：根在前，根左右
中序遍历：根在中，左根右
后续遍历：根在后，左右根

## 6、平衡二叉树（Balanced Binary Tree）
https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E6%A0%91

具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。

从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。

单旋：
左单旋：右子树A 的 左子树 链接到 A的父节点做为右孩子，父节点做为 A的左孩子。
右单旋：左子树B 的 右子树 链接到 B的父节点做为左孩子，父节点做为 B 的右孩子。
左旋右旋 AVL： https://blog.csdn.net/qq_37934101/article/details/81160254

## 7、红黑树

红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。(有些书籍根 红黑树根
据作者姓名，Adelson-Velskii和Landis，将其称为AVL-树)

红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。
它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。

红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:
性质1. 节点是红色或黑色。
性质2. 根节点是黑色。
性质3 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

## 8、AVL
AVL在计算机科学中是最先发明的自平衡二叉查找树。

## 9、红黑树与AVL树，各自的优缺点总结：

AVL是严格的平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；

红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低开销；

所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL树，

如果搜索，插入删除次数几乎差不多，应选择红黑树。即，有时仅为了排序（建立-遍历-删除），不查找或查找次数很少，R-B树合算一些。

红黑树与AVL树的调整平衡的实现机制不同，AVL靠平衡因子和旋转，红黑树靠节点颜色以及一些约定再加上旋转。因此，存在去掉颜色的红黑树后它不是AVL树，比如左子树都是黑的，右子树都是红黑相间的，这样整个树高度2n的时候，根节点的左右层数差可以到n。

---------------------

原文：https://www.jianshu.com/p/37436ed14cc6
其他参考：https://blog.csdn.net/zhangkunrun/article/details/38336543

补充：替罪羊树：
替罪羊树是一种依赖于暴力重构操作的平衡树。我们定义一个平衡树因子α ，对替罪羊树的每个节点t ，我们都需要满足：max（size l,size r）<=α*szie t其中l,r 分别是t 的左右子树。这个性质称为平衡性质。它的实现方式也非常简洁明了，每次我们进行普通 BST 的插入操作后，都要在这条插入的路径上，寻找最高的（深度最小）不满足平衡性质的节点，（如果有不满足平衡性质节点的话）我们将这个节点以及它的子树内所有节点，暴力重构成一棵完全二叉树。其余操作全部与普通 BST 无异。

存储引擎
---------------------

## 10、B 树
https://www.cnblogs.com/vincently/p/4526560.html

维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。”
定义

B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。
根节点至少有两个子节点
每个节点有M-1个key，并且以升序排列
位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
其它节点至少有M/2个子节点

补充:
2-3树:
2-3树是最简单的B-树（或-树）结构，其每个非叶节点都有两个或三个子女，而且所有叶节点都在统一层上。2-3树不是二叉树，其节点可拥有3个孩子。不过，2-3树与满二叉树相似。高为h的2-3树包含的节点数大于等于高度为h的满二叉树的节点数，即至少有2^h-1个节点。


## 11、B+树

B+树是对B树的一种变形树，它与B树的差异在于：
有k个子结点的结点必然有k个关键码；
非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

## 12、LSM

讲LSM树之前，需要提下三种基本的存储引擎，这样才能清楚LSM树的由来：
哈希存储引擎 是哈希表的持久化实现，支持增、删、改以及随机读取操作，但不支持顺序扫描，对应的存储系统为key-value存储系统。对于key-value的插入以及查询，哈希表的复杂度都是O(1)，明显比树的操作O(n)快,如果不需要有序的遍历数据，哈希表就是your Mr.Right
?  B树存储引擎是B树（关于B树的由来，数据结构以及应用场景可以看之前一篇博文）的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（B+树的叶子节点之间的指针），对应的存储系统就是关系数据库（Mysql等）。
?  LSM树（Log-Structured Merge Tree）存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。
通过以上的分析，应该知道LSM树的由来了，LSM树的设计思想非常朴素：将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘，不过读取的时候稍微麻烦，需要合并磁盘中历史数据和内存中最近修改操作，所以写入性能大大提升，读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件。极端的说，基于LSM树实现的HBase的写性能比Mysql高了一个数量级，读性能低了一个数量级。
LSM树原理把一棵大树拆分成N棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会flush到磁盘中，磁盘中的树定期可以做merge操作，合并成一棵大树，以优化读性能。

LSM参考1: https://www.cnblogs.com/yanghuahui/p/3483754.html
LSM参考2: https://blog.csdn.net/qq_38704184/article/details/88551223


